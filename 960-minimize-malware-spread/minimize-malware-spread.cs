public class Solution {
    public int MinMalwareSpread(int[][] graph, int[] initial) {
        int length = graph.Length;
        UnionFind unionFind = new UnionFind(length);

        for (int x = 0; x < length; x++)
        {
            for (int y = 0; y < length; y++)
            {
                if (graph[x][y] == 1)
                {
                    unionFind.Union(x, y);  
                }
            }
        }

        Dictionary<int, int> infected = new Dictionary<int, int>();
        Array.Sort(initial);

        for (int x = 0; x < initial.Length; x++)
        {
            int findIx = unionFind.Find(initial[x]);
            infected[findIx] = infected.ContainsKey(findIx) ? infected[findIx] + 1 : 1;
        }

        int candidateNode = initial[0];
        int maximumSize = 0;

       for (int i = 0; i < initial.Length; i++)
        {
            int root = unionFind.Find(initial[i]);
            int infectionCount = infected[root];
            int componentSize = unionFind.rank[root];

            if (infectionCount > 1)
            {
                continue;
            }

            if (componentSize > maximumSize)
            {
                maximumSize = componentSize;
                candidateNode = initial[i];
            }
            else if (componentSize == maximumSize && initial[i] < candidateNode)
            {
                candidateNode = initial[i];
            }
        }


        return candidateNode;
    }
}

public class UnionFind
{
    public int[] parent { get; private set; }
    public int[] rank { get; private set; }

    // Constructor to initialize the Union-Find data structure.
    public UnionFind(int n)
    {
        // Initialize the arrays to represent disjoint sets.
        parent = new int[n];
        rank = new int[n];
        
        // Initialize each element as its own parent and set rank to 1.
        for (int i = 0; i < n; i++)
        {
            parent[i] = i;
            rank[i] = 1;
        }
    }

    // Find the root (representative) of the set that v belongs to.
    public int Find(int v)
    {
        if (parent[v] == v)
        {
            return v; // v is already the root.
        }

        // Path compression: Update x's parent to the root to optimize future searches.
        return parent[v] = Find(parent[v]);
    }

    // Union two sets by attaching the smaller set to the larger set.
    public void Union(int v1, int v2)
    {
        int p1 = Find(v1);
        int p2 = Find(v2);

        if (p1 != p2)
        {
            // Union by rank: Attach the smaller set (p1) to the larger set (rootY).
            if (rank[p1] > rank[p2])
            {
                rank[p1] += rank[p2];
                parent[p2] = p1;
            }
            else
            {
                rank[p2] += rank[p1];
                parent[p1] = p2;
            }
        }
    }
}